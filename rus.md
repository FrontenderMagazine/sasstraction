# Сасстракция

Эмиль [экспериментировал с CSS-переменными][1] (вернее, «кастомными 
свойстами», так их правильнее называть), которые начали появляться в некоторых 
браузерах. Об этом определенно стоит почитать — Эмиль отлично объясняет, 
сколько потенциала содержится в этой новой фишке CSS.

Ну а пока для наших забот с переменными в основном используем препроцессоры 
вроде [Sass][2]. Именно о Sass говорил на прошлой неделе [Крис][3] на [An 
Event Apart в Сан-Франциско][4] — кстати, это мероприятие, как всегда, отлично 
удалось.

И в какой-то момент прозвучало следующее: Крис сказал, что его совершенно 
устроило бы, если бы переменные (на самом деле — константы) остались бы в 
Sass, а не включались в спецификацию CSS. К сожалению, я не смог кулуарно 
пообщаться об этом с Крисом, но мне кажется, что его ход мыслей совпадает с 
моим. Дело в том, что я тоже убежден, что CSS-переменные должны остаться в 
епархии препроцессоров, а не браузеров.

Послушайте мои аргументы.

Есть огромное количество отличных, мощных программных концептов, которые мы 
*могли* бы добавить в CSS: и, конечно, они сделали бы CSS более мощным языком. 
Но я думаю, что эти возможности придут вместе со своей ценой.

Сейчас [CSS — относительно простой язык][5]:

    CSS - не магия вуду, это простой, прямолинейный язык: вы объявляете, что у 
    элемента есть стиль, а дальше все происходит само.

Конечно, это несколько упрощенное описание, и, разумеется, у некоторых 
аспектов CSS есть ряд сложностей (скажем, [специфичность][6] или 
[схлопывание полей][7]) — но в целом, у CSS действительно довольно 
прямолинейный декларативный синтаксис.

    selector {
        property: value;
    }

Вот и все. Я думаю, что эта простота не только прекрасна сама по себе, но и 
позволяет сделать удивительно многое.

В моей [подборке принципов проектирования][8] есть секция с эссе Берта Боса 
[«Что такое хороший стандарт?»][9]. В теории эта статья посвящена стандартам 
проектирования в общем, но эти принципы, в частности, очень хорошо применимы к 
CSS.

Некоторые из слов, на которые стоит обратить внимание: [поддерживаемость][10], 
[модульность][11], [расширяемость][12], [простота][13], and [легкость для 
изучения][14]. Многие из этих принципов очевидно связаны. Я думаю, что в CSS 
эти принципы очень хорошо сбалансированы, при этом у веб-разработчиков все 
равно остается очень много возможностей сделать что-то с помощью CSS.

Если вернуться к этому фундаментальному паттерну CSS, то вы обратите внимание, 
что CSS полностью является модульным.

    selector {
        property: value;
    }

Все эти элементы (селектор, свойство, значение) не отсылают ни к чему больше в 
таблице стилей. Но если вы вносите сюда переменные, вся модульность 
рассыпается. Теперь есть переменная, которая отсылает к значению, 
определенному где-то в другом месте в таблице стилей (или вообще совсем в 
другой таблице стилей).

Но переменные не станут первым добавлением в CSS, которое приносит в жертву 
модульность. Это уже делают CSS-анимации. Если вы хотите подключить анимацию 
со стоп-кадрами, нужно ее где-то определить. Определение и подключение 
происходят в отдельных блоках:

    selector {
        animation-name: myanimation;
    }
    @keyframes myanimation {
        from {
            property: value;
        }
        to {
            property: value;
        }
    }    

Я не уверен, что есть какой-то способ лучше делать функциональные анимации в 
CSS, но из-за этой функции мы приносим в жертву модульность — и я думаю, что 
это скажется и на скорости понимания такого кода, и на его [читабельности][15].

Итак, CSS-переменные (они же кастомные свойства) — уже не первая трещинка в 
стене принципов проектирования CSS. Говоря метафорически, мы вступили на 
скользкую дорожку уже с @keyframes (а может быть, еще и с @font-face).

Никто не спорит с тем, что переменные/константы в CSS сделают его гораздо 
более мощным языком. Есть много программных концептов (циклы, функции и т.п.), 
которые дадут CSS намного больше возможностей. Но я не думаю, что смешивать 
декларативный и программный подход — хорошая идея. Мы видели, к чему это 
привело, смотря на XSLT — странного зверя, помесь как бы языка разметки с как 
бы языком программирования.

Я абсолютно уверен в том, что HTML и CSS должны остаться доступными для 
понимания языками. И не только для профессионалов. Я считаю, что безумно 
важно, чтобы *каждый* мог написать веб-страницу и стили к ней.

Значит ли это, что CSS так и должен оставаться хромоножкой? Нет, я так не 
думаю. Благодаря препроцессорам — например, Sass, можно и любить помидоры, и 
кушать их. Мы, профессионалы, вполне можен использовать такие инструменты, как 
Sass, чтобы пользоваться всем арсеналом переменных, функций (примесей) и 
других мощных концептом из мира программирования.

Препроцессоры разрубают тот гордиев узел, который сформировался в CSS из-за 
того, что хочется одновременно предоставлять разработчиком мощные возможности, 
но чтобы язык при этом оставался относительно легким для изучения. Вот поэтому 
я буду очень рад, если переменные, примеси, наследование и все такое останется 
целиком в области ответственности Sass.

Совпадение, но на An Event Apart Крис сказал, что сила Sass заключается в том, 
что это абстракция. Я не думаю, что это на самом деле так — пожалуй, тот факт, 
что Sass предлагает нам более высокий уровень абстракции, в действительности 
отвлекает нас от сути дела.

Крис выступил за то, что абстракции — это хорошо. По определению. Конечно, 
если спуститься достаточно вниз по дереву абстракций (до ассемблера), с этим 
не поспоришь. Но не все абстракции — хорошие абстракции, и я говорю не только 
про [закон дырявых абстракций Джоэля Спольски][16].

Вот смотрите, давайте возьмем две разные абстракции, которые создавались с 
одинаковыми исходными принципами:

*   [Sass][2] — слой абстракции над CSS.
*   [Haml][17] - слой абстракции над HTML.

Если бы абстракции были вселенским благом по определению, то оба этих примера 
приносили бы пользу. Но если Sass — отлично сделанный инструмент, который 
позволяет специалистам по CSS проще писать код, то Haml — извините, воняющая 
куча отбросов.

Вот ключевая разница: Sass не заставляет вас переписывать весь свой CSS 
совершенно заново. Собственно, каждый .css-файл автоматически является 
валидным .scss-файлом. Хотите — используйте какие-то возможности Sass, хотите 
- игнорируйте их, делайте все в своем темпе.

Haml, с другой стороны, заставляет вас использовать совершенно новый 
синтаксис, в котором имеют значение пробелы и отступы, и этот синтаксис уже 
трансформирует в HTML. Нет никаких полумер. Это не просто безапеляционная 
абстракция, но и такая, которая совершенно не желает вступать в разумный 
диалог.

Поэтому мое мнение, что Sass хорош не потому, что это абстракция, а потому что 
это *хорошо спроектированная* абстракция. А самое главное в Sass — то, что его 
[легко изучить][18] — точно так же, как CSS.

 [1]: http://thatemil.com/blog/2013/12/15/playing-around-with-css-variables-custom-properties/
 [2]: http://sass-lang.com/
 [3]: http://css-tricks.com/
 [4]: http://aneventapart.com/event/san-francisco-2013
 [5]: http://scottkellum.com/2013/12/11/ui-kit-is-dead.html
 [6]: http://cssspecificity.com/
 [7]: https://developer.mozilla.org/en-US/docs/Web/CSS/margin_collapsing
 [8]: http://principles.adactio.com/
 [9]: http://www.w3.org/People/Bos/DesignGuide/toc.html
 [10]: http://www.w3.org/People/Bos/DesignGuide/maintainability.html
 [11]: http://www.w3.org/People/Bos/DesignGuide/modularity.html
 [12]: http://www.w3.org/People/Bos/DesignGuide/extensibility.html
 [13]: http://www.w3.org/People/Bos/DesignGuide/simplicity.html
 [14]: http://www.w3.org/People/Bos/DesignGuide/learnability.html
 [15]: http://www.w3.org/People/Bos/DesignGuide/readability.html
 [16]: http://russian.joelonsoftware.com/Articles/LeakyAbstractions.html
 [17]: http://haml.info/
 [18]: http://www.abookapart.com/products/sass-for-web-designers